<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>RollUp Visualizer</title>
  <style>@font-face {
  font-family: "Oswald";
  font-style: normal;
  font-display: swap;
  font-weight: 500;
  src: local("Oswald Medium"), local("Oswald-Medium"), url("data:font/woff2;base64,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") format("woff2"), url("data:font/woff;base64,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") format("woff");
}
html {
  background-color: #f7eedf;
  color: #333;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  width: 100%;
}

body {
  width: 100%;
  padding: 0;
  margin: 0;
}

svg {
  vertical-align: middle;
}

h1 {
  font-family: "Oswald", "HelveticaNeue-CondensedBold", "Arial Narrow", sans-serif;
  font-weight: 500;
  font-size: 70px;
  text-transform: uppercase;
  text-align: center;
}

.chart {
  position: relative;
  margin: 0 auto;
  min-height: 350px;
}

#charts {
  width: 1000px;
  margin: 0 auto;
}

.tooltip {
  position: absolute;
  z-index: 1070;
  display: block;
  margin: 0;
  font-style: normal;
  font-weight: 400;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: 0.875rem;
  word-wrap: break-word;
  opacity: 0;
}

path {
  stroke: #fff;
}

#charts {
  width: 700px;
}

.details {
  position: absolute;
  top: 350px;
  left: 50%;
  width: 170px;
  margin-left: -85px;
  font-size: 14px;
  text-align: center;
  color: #eee;
  z-index: 100;
  overflow: hidden;
  text-overflow: ellipsis;
}

.details-size {
  font-size: 0.8em;
  margin-top: 1em;
}

.details-name {
  font-weight: bold;
}

.details-size::before {
  content: "(";
}

.details-size::after {
  content: ")";
}

.details-percentage {
  margin: 0.4em 0 0em;
  font-size: 2.4em;
  line-height: 1em;
}

rect {
  fill: cadetblue;
  opacity: 0.3;
  stroke: white;
}</style>
  <style>undefined</style>
</head>
<body>
  <h1>RollUp Visualizer</h1>
  <div id="charts"></div>
  <script>window.nodesData = [{"id":"shepherd.esm.min.js","root":{"name":"root","children":[{"name":"\u0000rollupPluginBabelHelpers.js","children":[],"size":3537,"originalSize":42833},{"name":"node_modules","children":[{"name":"tether","children":[{"name":"src","children":[{"name":"js","children":[{"name":"utils","children":[{"name":"type-check.js","children":[],"size":289,"originalSize":953}]},{"name":"evented.js","children":[],"size":1727,"originalSize":1232}]}]},{"name":"dist","children":[{"name":"js","children":[{"name":"tether.esm.js","children":[],"size":53604,"originalSize":53522}]}]}]},{"name":"svelte","children":[{"name":"internal","children":[{"name":"index.mjs","children":[],"size":10324,"originalSize":45574}]},{"name":"index.mjs","children":[],"size":0,"originalSize":129}]},{"name":"smoothscroll-polyfill","children":[{"name":"dist","children":[{"name":"smoothscroll.js","children":[],"size":11884,"originalSize":12239}]}]}]},{"name":"src","children":[{"name":"js","children":[{"name":"utils","children":[{"name":"auto-bind.js","children":[],"size":559,"originalSize":579},{"name":"type-check.js","children":[],"size":745,"originalSize":772},{"name":"bind.js","children":[],"size":1643,"originalSize":1643},{"name":"general.js","children":[],"size":3734,"originalSize":3913},{"name":"cleanup.js","children":[],"size":452,"originalSize":455}]},{"name":"components","children":[{"name":"shepherd-button.css","children":[],"size":0,"originalSize":6270},{"name":"shepherd-button.svelte","children":[],"size":3164,"originalSize":1509},{"name":"shepherd-footer.css","children":[],"size":0,"originalSize":2682},{"name":"shepherd-footer.svelte","children":[],"size":5496,"originalSize":615},{"name":"shepherd-cancel-icon.css","children":[],"size":0,"originalSize":4665},{"name":"shepherd-cancel-icon.svelte","children":[],"size":2100,"originalSize":977},{"name":"shepherd-title.css","children":[],"size":0,"originalSize":2382},{"name":"shepherd-title.svelte","children":[],"size":1855,"originalSize":551},{"name":"shepherd-header.css","children":[],"size":0,"originalSize":3417},{"name":"shepherd-header.svelte","children":[],"size":5334,"originalSize":896},{"name":"shepherd-text.css","children":[],"size":0,"originalSize":2879},{"name":"shepherd-text.svelte","children":[],"size":2025,"originalSize":740},{"name":"shepherd-content.css","children":[],"size":0,"originalSize":2147},{"name":"shepherd-content.svelte","children":[],"size":5945,"originalSize":742},{"name":"shepherd-element.css","children":[],"size":0,"originalSize":17108},{"name":"shepherd-element.svelte","children":[],"size":9699,"originalSize":5799},{"name":"shepherd-modal.css","children":[],"size":0,"originalSize":12574},{"name":"shepherd-modal.svelte","children":[],"size":9021,"originalSize":6398}]},{"name":"step.js","children":[],"size":13253,"originalSize":12746},{"name":"tour.js","children":[],"size":9781,"originalSize":9144},{"name":"shepherd.js","children":[],"size":56,"originalSize":146}]}]},{"name":"\u0000commonjsHelpers.js","children":[],"size":123,"originalSize":686}]}}];</script>
  <script>(function () {
  'use strict';

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function matcher(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove(); else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
  }

  function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_cloneShallow() {
    return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
  }

  function selection_cloneDeep() {
    return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
  }

  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  var filterEvents = {};

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!("onmouseenter" in element)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
      }
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function count(node) {
    var sum = 0,
        children = node.children,
        i = children && children.length;
    if (!i) sum = 1;
    else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }

  function node_count() {
    return this.eachAfter(count);
  }

  function node_each(callback) {
    var node = this, current, next = [node], children, i, n;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        callback(node), children = node.children;
        if (children) for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    } while (next.length);
    return this;
  }

  function node_eachBefore(callback) {
    var node = this, nodes = [node], children, i;
    while (node = nodes.pop()) {
      callback(node), children = node.children;
      if (children) for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
    return this;
  }

  function node_eachAfter(callback) {
    var node = this, nodes = [node], next = [], children, i, n;
    while (node = nodes.pop()) {
      next.push(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
    while (node = next.pop()) {
      callback(node);
    }
    return this;
  }

  function node_sum(value) {
    return this.eachAfter(function(node) {
      var sum = +value(node.data) || 0,
          children = node.children,
          i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  }

  function node_sort(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  function node_path(end) {
    var start = this,
        ancestor = leastCommonAncestor(start, end),
        nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }

  function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
        bNodes = b.ancestors(),
        c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }

  function node_ancestors() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  function node_descendants() {
    var nodes = [];
    this.each(function(node) {
      nodes.push(node);
    });
    return nodes;
  }

  function node_leaves() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  function node_links() {
    var root = this, links = [];
    root.each(function(node) {
      if (node !== root) { // Don’t include the root’s parent, if any.
        links.push({source: node.parent, target: node});
      }
    });
    return links;
  }

  function hierarchy(data, children) {
    var root = new Node(data),
        valued = +data.value && (root.value = data.value),
        node,
        nodes = [root],
        child,
        childs,
        i,
        n;

    if (children == null) children = defaultChildren;

    while (node = nodes.pop()) {
      if (valued) node.value = +node.data.value;
      if ((childs = children(node.data)) && (n = childs.length)) {
        node.children = new Array(n);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new Node(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }

    return root.eachBefore(computeHeight);
  }

  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }

  function defaultChildren(d) {
    return d.children;
  }

  function copyData(node) {
    node.data = node.data.data;
  }

  function computeHeight(node) {
    var height = 0;
    do node.height = height;
    while ((node = node.parent) && (node.height < ++height));
  }

  function Node(data) {
    this.data = data;
    this.depth =
    this.height = 0;
    this.parent = null;
  }

  Node.prototype = hierarchy.prototype = {
    constructor: Node,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy
  };

  function roundNode(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  function treemapDice(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (x1 - x0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.y0 = y0, node.y1 = y1;
      node.x0 = x0, node.x1 = x0 += node.value * k;
    }
  }

  function d3partition() {
    var dx = 1,
        dy = 1,
        padding = 0,
        round = false;

    function partition(root) {
      var n = root.height + 1;
      root.x0 =
      root.y0 = padding;
      root.x1 = dx;
      root.y1 = dy / n;
      root.eachBefore(positionNode(dy, n));
      if (round) root.eachBefore(roundNode);
      return root;
    }

    function positionNode(dy, n) {
      return function(node) {
        if (node.children) {
          treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
        }
        var x0 = node.x0,
            y0 = node.y0,
            x1 = node.x1 - padding,
            y1 = node.y1 - padding;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
      };
    }

    partition.round = function(x) {
      return arguments.length ? (round = !!x, partition) : round;
    };

    partition.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
    };

    partition.padding = function(x) {
      return arguments.length ? (padding = +x, partition) : padding;
    };

    return partition;
  }

  var pi = Math.PI,
      tau = 2 * pi,
      epsilon = 1e-6,
      tauEpsilon = tau - epsilon;

  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path() {
    return new Path;
  }

  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function(x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
      this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon));

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Otherwise, draw an arc!
      else {
        var x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

        // If the start tangent is not coincident with (x0,y0), line to.
        if (Math.abs(t01 - 1) > epsilon) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }

        this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._ += "L" + x0 + "," + y0;
      }

      // Is this arc empty? We’re done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau + tau;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon) {
        this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
    },
    rect: function(x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
    },
    toString: function() {
      return this._;
    }
  };

  function constant$1(x) {
    return function constant() {
      return x;
    };
  }

  var abs = Math.abs;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var max = Math.max;
  var min = Math.min;
  var sin = Math.sin;
  var sqrt = Math.sqrt;

  var epsilon$1 = 1e-12;
  var pi$1 = Math.PI;
  var halfPi = pi$1 / 2;
  var tau$1 = 2 * pi$1;

  function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
  }

  function asin(x) {
    return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
  }

  function arcInnerRadius(d) {
    return d.innerRadius;
  }

  function arcOuterRadius(d) {
    return d.outerRadius;
  }

  function arcStartAngle(d) {
    return d.startAngle;
  }

  function arcEndAngle(d) {
    return d.endAngle;
  }

  function arcPadAngle(d) {
    return d && d.padAngle; // Note: optional!
  }

  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0, y10 = y1 - y0,
        x32 = x3 - x2, y32 = y3 - y2,
        t = y32 * x10 - x32 * y10;
    if (t * t < epsilon$1) return;
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [x0 + t * x10, y0 + t * y10];
  }

  // Compute perpendicular offset line of length rc.
  // http://mathworld.wolfram.com/Circle-LineIntersection.html
  function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
    var x01 = x0 - x1,
        y01 = y0 - y1,
        lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
        ox = lo * y01,
        oy = -lo * x01,
        x11 = x0 + ox,
        y11 = y0 + oy,
        x10 = x1 + ox,
        y10 = y1 + oy,
        x00 = (x11 + x10) / 2,
        y00 = (y11 + y10) / 2,
        dx = x10 - x11,
        dy = y10 - y11,
        d2 = dx * dx + dy * dy,
        r = r1 - rc,
        D = x11 * y10 - x10 * y11,
        d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
        cx0 = (D * dy - dx * d) / d2,
        cy0 = (-D * dx - dy * d) / d2,
        cx1 = (D * dy + dx * d) / d2,
        cy1 = (-D * dx + dy * d) / d2,
        dx0 = cx0 - x00,
        dy0 = cy0 - y00,
        dx1 = cx1 - x00,
        dy1 = cy1 - y00;

    // Pick the closer of the two intersection points.
    // TODO Is there a faster way to determine which intersection to use?
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }

  function d3arc() {
    var innerRadius = arcInnerRadius,
        outerRadius = arcOuterRadius,
        cornerRadius = constant$1(0),
        padRadius = null,
        startAngle = arcStartAngle,
        endAngle = arcEndAngle,
        padAngle = arcPadAngle,
        context = null;

    function arc() {
      var buffer,
          r,
          r0 = +innerRadius.apply(this, arguments),
          r1 = +outerRadius.apply(this, arguments),
          a0 = startAngle.apply(this, arguments) - halfPi,
          a1 = endAngle.apply(this, arguments) - halfPi,
          da = abs(a1 - a0),
          cw = a1 > a0;

      if (!context) context = buffer = path();

      // Ensure that the outer radius is always larger than the inner radius.
      if (r1 < r0) r = r1, r1 = r0, r0 = r;

      // Is it a point?
      if (!(r1 > epsilon$1)) context.moveTo(0, 0);

      // Or is it a circle or annulus?
      else if (da > tau$1 - epsilon$1) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$1) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      }

      // Or is it a circular or annular sector?
      else {
        var a01 = a0,
            a11 = a1,
            a00 = a0,
            a10 = a1,
            da0 = da,
            da1 = da,
            ap = padAngle.apply(this, arguments) / 2,
            rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
            rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
            rc0 = rc,
            rc1 = rc,
            t0,
            t1;

        // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
        if (rp > epsilon$1) {
          var p0 = asin(rp / r0 * sin(ap)),
              p1 = asin(rp / r1 * sin(ap));
          if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }

        var x01 = r1 * cos(a01),
            y01 = r1 * sin(a01),
            x10 = r0 * cos(a10),
            y10 = r0 * sin(a10);

        // Apply rounded corners?
        if (rc > epsilon$1) {
          var x11 = r1 * cos(a11),
              y11 = r1 * sin(a11),
              x00 = r0 * cos(a00),
              y00 = r0 * sin(a00),
              oc;

          // Restrict the corner radius according to the sector angle.
          if (da < pi$1 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min(rc, (r0 - lc) / (kc - 1));
            rc1 = min(rc, (r1 - lc) / (kc + 1));
          }
        }

        // Is the sector collapsed to a line?
        if (!(da1 > epsilon$1)) context.moveTo(x01, y01);

        // Does the sector’s outer ring have rounded corners?
        else if (rc1 > epsilon$1) {
          t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
          t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

          context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

          // Have the corners merged?
          if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

          // Otherwise, draw the two corners and the ring.
          else {
            context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
            context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
          }
        }

        // Or is the outer ring just a circular arc?
        else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

        // Is there no inner ring, and it’s a circular sector?
        // Or perhaps it’s an annular sector collapsed due to padding?
        if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);

        // Does the sector’s inner ring (or point) have rounded corners?
        else if (rc0 > epsilon$1) {
          t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

          context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

          // Have the corners merged?
          if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

          // Otherwise, draw the two corners and the ring.
          else {
            context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
            context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
          }
        }

        // Or is the inner ring just a circular arc?
        else context.arc(0, 0, r0, a10, a00, cw);
      }

      context.closePath();

      if (buffer) return context = null, buffer + "" || null;
    }

    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
          a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
      return [cos(a) * r, sin(a) * r];
    };

    arc.innerRadius = function(_) {
      return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
    };

    arc.outerRadius = function(_) {
      return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
    };

    arc.cornerRadius = function(_) {
      return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
    };

    arc.padRadius = function(_) {
      return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
    };

    arc.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
    };

    arc.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
    };

    arc.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
    };

    arc.context = function(_) {
      return arguments.length ? ((context = _ == null ? null : _), arc) : context;
    };

    return arc;
  }

  function sign(x) {
    return x < 0 ? -1 : 1;
  }

  // Calculate the slopes of the tangents (Hermite-type interpolation) based on
  // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
  // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
  // NOV(II), P. 443, 1990.
  function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0,
        h1 = x2 - that._x1,
        s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
        s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
        p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }

  // Calculate a one-sided slope.
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }

  // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
  // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
  function point(that, t0, t1) {
    var x0 = that._x0,
        y0 = that._y0,
        x1 = that._x1,
        y1 = that._y1,
        dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
  }

  function MonotoneX(context) {
    this._context = context;
  }

  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 =
      this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2: this._context.lineTo(this._x1, this._y1); break;
        case 3: point(this, this._t0, slope2(this, this._t0)); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      var t1 = NaN;

      x = +x, y = +y;
      if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
        default: point(this, this._t0, t1 = slope3(this, x, y)); break;
      }

      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
      this._t0 = t1;
    }
  };

  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }

  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
    MonotoneX.prototype.point.call(this, y, x);
  };

  function ReflectContext(context) {
    this._context = context;
  }

  ReflectContext.prototype = {
    moveTo: function(x, y) { this._context.moveTo(y, x); },
    closePath: function() { this._context.closePath(); },
    lineTo: function(x, y) { this._context.lineTo(y, x); },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
  };

  function ascending$1(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending$1(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending$1);
  var bisectRight = ascendingBisect.right;

  var e10 = Math.sqrt(50),
      e5 = Math.sqrt(10),
      e2 = Math.sqrt(2);

  function ticks(start, stop, count) {
    var reverse,
        i = -1,
        n,
        ticks,
        step;

    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [start];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
      start = Math.ceil(start / step);
      stop = Math.floor(stop / step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) * step;
    } else {
      start = Math.floor(start * step);
      stop = Math.ceil(stop * step);
      ticks = new Array(n = Math.ceil(start - stop + 1));
      while (++i < n) ticks[i] = (start - i) / step;
    }

    if (reverse) ticks.reverse();

    return ticks;
  }

  function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0
        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function initRange(domain, range) {
    switch (arguments.length) {
      case 0: break;
      case 1: this.range(domain); break;
      default: this.range(range).domain(domain); break;
    }
    return this;
  }

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex3 = /^#([0-9a-f]{3})$/,
      reHex6 = /^#([0-9a-f]{6})$/,
      reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
      reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
      reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
      reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
      reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
      reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: function() {
      return this.rgb().hex();
    },
    toString: function() {
      return this.rgb() + "";
    }
  });

  function color(format) {
    var m;
    format = (format + "").trim().toLowerCase();
    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format])
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: function() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    },
    toString: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  var deg2rad = Math.PI / 180;
  var rad2deg = 180 / Math.PI;

  // https://observablehq.com/@mbostock/lab-and-rgb
  var K = 18,
      Xn = 0.96422,
      Yn = 1,
      Zn = 0.82521,
      t0 = 4 / 29,
      t1 = 6 / 29,
      t2 = 3 * t1 * t1,
      t3 = t1 * t1 * t1;

  function labConvert(o) {
    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl) return hcl2lab(o);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = rgb2lrgb(o.r),
        g = rgb2lrgb(o.g),
        b = rgb2lrgb(o.b),
        y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
    if (r === g && g === b) x = z = y; else {
      x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
      z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
    }
    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
  }

  function lab(l, a, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
  }

  function Lab(l, a, b, opacity) {
    this.l = +l;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Lab, lab, extend(Color, {
    brighter: function(k) {
      return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker: function(k) {
      return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb: function() {
      var y = (this.l + 16) / 116,
          x = isNaN(this.a) ? y : y + this.a / 500,
          z = isNaN(this.b) ? y : y - this.b / 200;
      x = Xn * lab2xyz(x);
      y = Yn * lab2xyz(y);
      z = Zn * lab2xyz(z);
      return new Rgb(
        lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
        lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
        lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
        this.opacity
      );
    }
  }));

  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
  }

  function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
  }

  function lrgb2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }

  function rgb2lrgb(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }

  function hclConvert(o) {
    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab)) o = labConvert(o);
    if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * rad2deg;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }

  function hcl(h, c, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
  }

  function Hcl(h, c, l, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l;
    this.opacity = +opacity;
  }

  function hcl2lab(o) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }

  define(Hcl, hcl, extend(Color, {
    brighter: function(k) {
      return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
    },
    darker: function(k) {
      return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
    },
    rgb: function() {
      return hcl2lab(this).rgb();
    }
  }));

  var A = -0.14861,
      B = +1.78277,
      C = -0.29227,
      D = -0.90649,
      E = +1.97294,
      ED = E * D,
      EB = E * B,
      BC_DA = B * C - D * A;

  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
        bl = b - l,
        k = (E * (g - l) - C * bl) / D,
        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
  }

  function cubehelix(h, s, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
  }

  function Cubehelix(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Cubehelix, cubehelix, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
          l = +this.l,
          a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
          cosh = Math.cos(h),
          sinh = Math.sin(h);
      return new Rgb(
        255 * (l + a * (A * cosh + B * sinh)),
        255 * (l + a * (C * cosh + D * sinh)),
        255 * (l + a * (E * cosh)),
        this.opacity
      );
    }
  }));

  function constant$2(x) {
    return function() {
      return x;
    };
  }

  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant$2(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant$2(isNaN(a) ? b : a);
  }

  var rgb$1 = (function rgbGamma(y) {
    var color = gamma(y);

    function rgb$1(start, end) {
      var r = color((start = rgb(start)).r, (end = rgb(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb$1.gamma = rgbGamma;

    return rgb$1;
  })(1);

  function array(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date(a, b) {
    var d = new Date;
    return a = +a, b -= a, function(t) {
      return d.setTime(a + b * t), d;
    };
  }

  function interpolateNumber(a, b) {
    return a = +a, b -= a, function(t) {
      return a + b * t;
    };
  }

  function object(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolateValue(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");

  function zero(b) {
    return function() {
      return b;
    };
  }

  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function string(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: interpolateNumber(am, bm)});
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function interpolateValue(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant$2(b)
        : (t === "number" ? interpolateNumber
        : t === "string" ? ((c = color(b)) ? (b = c, rgb$1) : string)
        : b instanceof color ? rgb$1
        : b instanceof Date ? date
        : Array.isArray(b) ? array
        : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
        : interpolateNumber)(a, b);
  }

  function interpolateRound(a, b) {
    return a = +a, b -= a, function(t) {
      return Math.round(a + b * t);
    };
  }

  var degrees = 180 / Math.PI;

  var rho = Math.SQRT2;

  function constant$3(x) {
    return function() {
      return x;
    };
  }

  function number(x) {
    return +x;
  }

  var unit = [0, 1];

  function identity(x) {
    return x;
  }

  function normalize(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant$3(isNaN(b) ? NaN : 0.5);
  }

  function clamper(domain) {
    var a = domain[0], b = domain[domain.length - 1], t;
    if (a > b) t = a, a = b, b = t;
    return function(x) { return Math.max(a, Math.min(b, x)); };
  }

  // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
  function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r[i] = interpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = bisectRight(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp())
        .unknown(source.unknown());
  }

  function transformer() {
    var domain = unit,
        range = unit,
        interpolate = interpolateValue,
        transform,
        untransform,
        unknown,
        clamp = identity,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }

    scale.invert = function(y) {
      return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = Array.from(_), interpolate = interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }

  function continuous(transform, untransform) {
    return transformer()(transform, untransform);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    this.fill = match[1] || " ";
    this.align = match[2] || ">";
    this.sign = match[3] || "-";
    this.symbol = match[4] || "";
    this.zero = !!match[5];
    this.width = match[6] && +match[6];
    this.comma = !!match[7];
    this.precision = match[8] && +match[8].slice(1);
    this.trim = !!match[9];
    this.type = match[10] || "";
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  function identity$1(x) {
    return x;
  }

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$1,
        currency = locale.currency,
        decimal = locale.decimal,
        numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$1,
        percent = locale.percent || "%";

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Perform the initial formatting.
          var valueNegative = value < 0;
          value = formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim(value);

          // If a negative value rounds to zero during formatting, treat as positive.
          if (valueNegative && +value === 0) valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  var format;
  var formatPrefix;

  defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  }

  function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count),
        precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };

    scale.nice = function(count) {
      if (count == null) count = 10;

      var d = domain(),
          i0 = 0,
          i1 = d.length - 1,
          start = d[i0],
          stop = d[i1],
          step;

      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }

      step = tickIncrement(start, stop, count);

      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count);
      }

      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear$1() {
    var scale = continuous(identity, identity);

    scale.copy = function() {
      return copy(scale, linear$1());
    };

    initRange.apply(scale, arguments);

    return linearish(scale);
  }

  function transformPow(exponent) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
  }

  function transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  }

  function transformSquare(x) {
    return x < 0 ? -x * x : x * x;
  }

  function powish(transform) {
    var scale = transform(identity, identity),
        exponent = 1;

    function rescale() {
      return exponent === 1 ? transform(identity, identity)
          : exponent === 0.5 ? transform(transformSqrt, transformSquare)
          : transform(transformPow(exponent), transformPow(1 / exponent));
    }

    scale.exponent = function(_) {
      return arguments.length ? (exponent = +_, rescale()) : exponent;
    };

    return linearish(scale);
  }

  function pow() {
    var scale = powish(transformer());

    scale.copy = function() {
      return copy(scale, pow()).exponent(scale.exponent());
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function sqrt$1() {
    return pow.apply(null, arguments).exponent(0.5);
  }

  var t0$1 = new Date,
      t1$1 = new Date;

  function newInterval(floori, offseti, count, field) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };

    interval.round = function(date) {
      var d0 = interval(date),
          d1 = interval.ceil(date);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [], previous;
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
      while (previous < start && start < stop);
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        if (date >= date) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
          } else while (--step >= 0) {
            while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
          }
        }
      });
    };

    if (count) {
      interval.count = function(start, end) {
        t0$1.setTime(+start), t1$1.setTime(+end);
        floori(t0$1), floori(t1$1);
        return Math.floor(count(t0$1, t1$1));
      };

      interval.every = function(step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null
            : !(step > 1) ? interval
            : interval.filter(field
                ? function(d) { return field(d) % step === 0; }
                : function(d) { return interval.count(0, d) % step === 0; });
      };
    }

    return interval;
  }

  var millisecond = newInterval(function() {
    // noop
  }, function(date, step) {
    date.setTime(+date + step);
  }, function(start, end) {
    return end - start;
  });

  // An optimized implementation for this simple case.
  millisecond.every = function(k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return newInterval(function(date) {
      date.setTime(Math.floor(date / k) * k);
    }, function(date, step) {
      date.setTime(+date + step * k);
    }, function(start, end) {
      return (end - start) / k;
    });
  };

  var durationSecond = 1e3;
  var durationMinute = 6e4;
  var durationHour = 36e5;
  var durationDay = 864e5;
  var durationWeek = 6048e5;

  var second = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds());
  }, function(date, step) {
    date.setTime(+date + step * durationSecond);
  }, function(start, end) {
    return (end - start) / durationSecond;
  }, function(date) {
    return date.getUTCSeconds();
  });

  var minute = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute);
  }, function(start, end) {
    return (end - start) / durationMinute;
  }, function(date) {
    return date.getMinutes();
  });

  var hour = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
  }, function(date, step) {
    date.setTime(+date + step * durationHour);
  }, function(start, end) {
    return (end - start) / durationHour;
  }, function(date) {
    return date.getHours();
  });

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
  }, function(date) {
    return date.getDate() - 1;
  });

  function weekday(i) {
    return newInterval(function(date) {
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);
  var tuesday = weekday(2);
  var wednesday = weekday(3);
  var thursday = weekday(4);
  var friday = weekday(5);
  var saturday = weekday(6);

  var month = newInterval(function(date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setMonth(date.getMonth() + step);
  }, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, function(date) {
    return date.getMonth();
  });

  var year = newInterval(function(date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  }, function(date) {
    return date.getFullYear();
  });

  // An optimized implementation for this simple case.
  year.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step * k);
    });
  };

  var utcMinute = newInterval(function(date) {
    date.setUTCSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute);
  }, function(start, end) {
    return (end - start) / durationMinute;
  }, function(date) {
    return date.getUTCMinutes();
  });

  var utcHour = newInterval(function(date) {
    date.setUTCMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationHour);
  }, function(start, end) {
    return (end - start) / durationHour;
  }, function(date) {
    return date.getUTCHours();
  });

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / durationDay;
  }, function(date) {
    return date.getUTCDate() - 1;
  });

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / durationWeek;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);

  var utcMonth = newInterval(function(date) {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, function(date) {
    return date.getUTCMonth();
  });

  var utcYear = newInterval(function(date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, function(date) {
    return date.getUTCFullYear();
  });

  // An optimized implementation for this simple case.
  utcYear.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
  };

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newYear(y) {
    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
  }

  function formatLocale$1(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function(date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        if (!(date instanceof Date)) date = new Date(+date);

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
            else pad = c === "e" ? " " : "0";
            if (format = formats[c]) c = format(date, pad);
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, newDate) {
      return function(string) {
        var d = newYear(1900),
            i = parseSpecifier(d, specifier, string += "", 0),
            week, day$1;
        if (i != string.length) return null;

        // If a UNIX timestamp is specified, return it.
        if ("Q" in d) return new Date(d.Q);

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // Convert day-of-week and week-of-year to day-of-year.
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) return null;
          if (!("w" in d)) d.w = 1;
          if ("Z" in d) {
            week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
            week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = newDate(newYear(d.y)), day$1 = week.getDay();
            week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
            week = day.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
        }

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        return newDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() { return specifier; };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", localDate);
        p.toString = function() { return specifier; };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() { return specifier; };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier, utcDate);
        p.toString = function() { return specifier; };
        return p;
      }
    };
  }

  var pads = {"-": "", "_": " ", "0": "0"},
      numberRe = /^\s*\d+/, // note: ignores next directive
      percentRe = /^%/,
      requoteRe = /[\\^$*+?|[\]().{}]/g;

  function pad(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    var map = {}, i = -1, n = names.length;
    while (++i < n) map[names[i].toLowerCase()] = i;
    return map;
  }

  function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }

  function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad(1 + day.count(year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }

  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }

  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }

  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }

  function formatWeekNumberSunday(d, p) {
    return pad(sunday.count(year(d), d), p, 2);
  }

  function formatWeekNumberISO(d, p) {
    var day = d.getDay();
    d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
  }

  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad(monday.count(year(d), d), p, 2);
  }

  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad(z / 60 | 0, "0", 2)
        + pad(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }

  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d), d), p, 2);
  }

  function formatUTCWeekNumberISO(d, p) {
    var day = d.getUTCDay();
    d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }

  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d), d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  function formatUnixTimestamp(d) {
    return +d;
  }

  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1000);
  }

  var locale$1;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;

  defaultLocale$1({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    timeFormat = locale$1.format;
    timeParse = locale$1.parse;
    utcFormat = locale$1.utcFormat;
    utcParse = locale$1.utcParse;
    return locale$1;
  }

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

  function formatIsoNative(date) {
    return date.toISOString();
  }

  var formatIso = Date.prototype.toISOString
      ? formatIsoNative
      : utcFormat(isoSpecifier);

  function parseIsoNative(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  }

  var parseIso = +new Date("2000-01-01T00:00:00.000Z")
      ? parseIsoNative
      : utcParse(isoSpecifier);

  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  var format_1 = format$1;

  /**
   * Module variables.
   * @private
   */

  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

  var map = {
    b:  1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5),
  };

  /**
   * Format the given value in bytes into a string.
   *
   * If the value is negative, it is kept as such. If it is a float,
   * it is rounded.
   *
   * @param {number} value
   * @param {object} [options]
   * @param {number} [options.decimalPlaces=2]
   * @param {number} [options.fixedDecimals=false]
   * @param {string} [options.thousandsSeparator=]
   * @param {string} [options.unit=]
   * @param {string} [options.unitSeparator=]
   *
   * @returns {string|null}
   * @public
   */

  function format$1(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }

    var mag = Math.abs(value);
    var thousandsSeparator = (options && options.thousandsSeparator) || '';
    var unitSeparator = (options && options.unitSeparator) || '';
    var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = (options && options.unit) || '';

    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = 'PB';
      } else if (mag >= map.tb) {
        unit = 'TB';
      } else if (mag >= map.gb) {
        unit = 'GB';
      } else if (mag >= map.mb) {
        unit = 'MB';
      } else if (mag >= map.kb) {
        unit = 'KB';
      } else {
        unit = 'B';
      }
    }

    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);

    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, '$1');
    }

    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }

    return str + unitSeparator + unit;
  }

  function getAncestors(node) {
    const parents = [];
    while (node != null) {
      parents.push(node);
      node = node.parent;
    }
    return parents;
  }

  function color$1(node) {
    if (node.children && node.children.length) {
      const parents = getAncestors(node);
      const hasNodeModules = !!parents.find(n => {
        return n.data.name === "node_modules";
      });
      return hasNodeModules ? "#599e59" : "#487ea4";
    } else {
      return "#db7100";
    }
  }

  const WIDTH = 700;
  const HEIGHT = 700;
  const RADIUS = Math.min(WIDTH, HEIGHT) / 2 - 10;

  const x = linear$1().range([0, 2 * Math.PI]);
  const y = sqrt$1().range([0, RADIUS]);

  const chartsContainer = document.querySelector("#charts");

  for (const { id, root: data } of window.nodesData) {
    const wrapper = document.createElement("div");
    wrapper.innerHTML = `
    <div class="chart">
      <h3>${id}</h3>
      <div class="details" style="display: none;">
        <div class="details-name" ></div>
        <div class="details-percentage" ></div>
        of bundle size
        <div class="details-size" ></div>
      </div>
    </div>
    `;
    const chartNode = wrapper.querySelector(".chart");
    chartsContainer.appendChild(chartNode);

    const g = select(chartNode)
      .append("svg")
      .attr("viewBox", [0, 0, WIDTH, HEIGHT])
      .append("g")
      .attr("transform", `translate(${WIDTH / 2},${HEIGHT / 2})`);

    const root = hierarchy(data)
      .sum(d => {
        if (d.children && d.children.length) {
          return 0;
        } else {
          return d.size;
        }
      })
      .sort();

    const arc = d3arc()
      .startAngle(d => Math.max(0, Math.min(2 * Math.PI, x(d.x0))))
      .endAngle(d => Math.max(0, Math.min(2 * Math.PI, x(d.x1))))
      .innerRadius(d => y(d.y0))
      .outerRadius(d => y(d.y1));

    const partition = d3partition();

    partition(root);

    g.selectAll("path")
      .data(partition(root).descendants())
      .enter()
      .append("path")

      .attr("d", arc)
      .attr("fill-rule", "evenodd")
      .style("stroke", "#fff")
      .style("fill", d => color$1(d))
      .on("mouseover", d => {
        const percentageNum = (100 * d.value) / totalSize;
        const percentage = percentageNum.toFixed(2);
        const percentageString = percentage + "%";

        select(chartNode)
          .select(".details-name")
          .text(d.data.name);

        select(chartNode)
          .select(".details-percentage")
          .text(percentageString);

        select(chartNode)
          .select(".details-size")
          .text(format_1(d.value));

        select(chartNode)
          .select(".details")
          .style("display", "block");

        const sequenceArray = getAncestors(d);
        //updateBreadcrumbs(sequenceArray, percentageString);

        // Fade all the segments.
        g.selectAll("path").style("opacity", 0.3);

        // Then highlight only those that are an ancestor of the current segment.
        g.selectAll("path")
          .filter(node => sequenceArray.indexOf(node) >= 0)
          .style("opacity", 1);
      });

    const totalSize = root.value;

    select(chartNode).on("mouseleave", () => {
      g.selectAll("path").style("opacity", 1);

      select(".details").style("display", "none");
    });
  }

}());
</script>
</body>
</html>
